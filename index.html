<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>glTF ビューワー</title>
<style>
  html,body{height:100%;margin:0;background:#0b1020;color:#e5e7eb;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP","Meiryo",sans-serif}
  #app{display:grid;grid-template-rows:auto 1fr;height:100%}
  header{display:grid;grid-template-columns:1fr auto auto auto;gap:8px;align-items:center;padding:10px;background:#0f172a}
  .title{font-weight:700}
  #canvas{width:100%;height:100%;display:block;touch-action:none}
  .panel{position:absolute;top:12px;right:12px;min-width:340px;max-width:46vw;background:rgba(15,23,42,.9);padding:12px;border-radius:12px;box-shadow:0 10px 25px rgba(0,0,0,.35)}
  .row{display:grid;grid-template-columns:1fr auto;gap:8px;margin-bottom:8px}
  select,button,input[type="range"],label{border-radius:8px;border:1px solid #334155;background:#111827;color:#e5e7eb;padding:6px 8px}
  button:disabled{opacity:.5}
  .log{font:12px/1.4 ui-monospace,Consolas,Menlo,monospace;white-space:pre-wrap;background:#0b1222;border:1px solid #334155;border-radius:8px;padding:8px;max-height:28vh;overflow:auto}
  .tag{font-size:12px;padding:2px 6px;border:1px solid #334155;border-radius:999px;color:#cbd5e1}
  #err{position:fixed;left:12px;bottom:12px;max-width:56vw;background:#7f1d1d;color:#fecaca;padding:8px 10px;border-radius:8px;font:12px/1.4 ui-monospace;display:none;white-space:pre-wrap}
  .cursor-move{cursor:move}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.1/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.1/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="app">
  <header>
    <label title=".gltf/.glb（gltfは.binと同フォルダ）を選択">
      <input id="filesFolder" type="file" multiple webkitdirectory />
      フォルダ選択
    </label>
    <label title=".gltf/.glb 単体または複数ファイル選択">
      <input id="filesFiles" type="file" multiple accept=".gltf,.glb,.bin,.png,.jpg,.jpeg,.webp,.ktx2,.ktx,.bmp,.gif,.tga" />
      ファイル選択
    </label>
    <button id="btnUndo" disabled>元に戻す</button>
    <button id="btnRedo" disabled>やり直す</button>
    <button id="btnGyro">ジャイロ開始 V0.1.1</button>
  </header>

  <div id="viewport" style="position:relative;">
    <canvas id="canvas"></canvas>

    <div class="panel" id="panel" hidden>
      <div class="row">
        <label for="boneSelect">ボーン</label>
        <select id="boneSelect"></select>
      </div>
      <div class="row">
        <label for="movePlane">移動平面</label>
        <select id="movePlane">
          <option value="screen" selected>スクリーン平面（カメラ面）</option>
          <option value="world">ワールド XZ 平面（Y固定）</option>
        </select>
      </div>
      <div class="row">
        <label><input type="checkbox" id="chkShowPickers"> ピッカー表示</label>
        <span></span>
      </div>
      <div><strong>ログ</strong></div>
      <div class="log" id="log">—</div>
    </div>
  </div>
</div>
<div id="err"></div>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

/* ===== エラー可視化 ===== */
const errBox=document.getElementById('err');
function showErr(msg){ errBox.style.display='block'; errBox.textContent=String(msg); }
addEventListener('error',e=>showErr(e.message||e.error));
addEventListener('unhandledrejection',e=>showErr(e.reason?.message||e.reason||'Unhandled rejection'));

/* ===== DOM ===== */
const canvas=document.getElementById("canvas");
const filesInputFolder=document.getElementById("filesFolder");
const filesInputFiles=document.getElementById("filesFiles");
const panel=document.getElementById("panel");
const logEl=document.getElementById("log");
const boneSelect=document.getElementById("boneSelect");
const movePlaneSel=document.getElementById("movePlane");
const chkShowPickers=document.getElementById("chkShowPickers");
const btnUndo=document.getElementById("btnUndo");
const btnRedo=document.getElementById("btnRedo");
const btnGyro=document.getElementById("btnGyro");
function log(...a){ logEl.textContent+=a.join(" ")+"\n"; logEl.scrollTop=logEl.scrollHeight; }
const fmtV=(v)=>v?`(${v.x.toFixed(3)},${v.y.toFixed(3)},${v.z.toFixed(3)})`:"(-)";
const fmtQ=(q)=>q?`(${q.x.toFixed(4)},${q.y.toFixed(4)},${q.z.toFixed(4)},${q.w.toFixed(4)})`:"(-)";
const fmtN=(n,d=4)=>n===undefined?"" : n.toFixed(d);
const radToDeg=(r)=>r*180/Math.PI;

/* ===== Three ===== */
const renderer=new THREE.WebGLRenderer({ antialias:true, canvas, alpha:true });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace=THREE.SRGBColorSpace;

const scene=new THREE.Scene(); scene.background=new THREE.Color(0x0b1020);
const camera=new THREE.PerspectiveCamera(45,1,0.01,50000); camera.position.set(0,1.2,3);

const controls=new OrbitControls(camera, renderer.domElement);
controls.enableDamping=true;
controls.mouseButtons={ MIDDLE:THREE.MOUSE.PAN, RIGHT:THREE.MOUSE.ROTATE };
controls.touches={ ONE:THREE.TOUCH.ROTATE, TWO:THREE.TOUCH.DOLLY_PAN };

scene.add(new THREE.GridHelper(10,10,0x234,0x123));
scene.add(new THREE.AmbientLight(0xffffff,0.7));
const dir=new THREE.DirectionalLight(0xffffff,2.0); dir.position.set(2,5,4); scene.add(dir);

/* ===== Loader（テクスチャ無視） ===== */
const loader=new GLTFLoader();
const px1="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=";
const filesMap=new Map();
loader.manager.setURLModifier((url)=>{
  const u=decodeURI(url).replace(/\\/g,"/");
  if(/\.(png|jpg|jpeg|webp|ktx2|ktx|bmp|gif|tga)$/i.test(u)) return px1;
  const k1=u, k2=u.replace(/^\.\/+/, ""), k3=k2.toLowerCase();
  return filesMap.get(k1)||filesMap.get(k2)||filesMap.get(k3)||url;
});

/* ===== 状態 ===== */
let model=null, skeleton=null, skeletonHelper=null, bones=[];
let selectedBone=null;
const raycaster=new THREE.Raycaster(), mouseNDC=new THREE.Vector2();
let modelRoot=new THREE.Group(); scene.add(modelRoot);

/* IK 休止情報（Local & World 参照） */
const ikMap=new Map(); // child -> { parent, restLen, restDirLocal, restUpLocal, parentRestLocalQ, restDirWorld, parentRestWorldQ, parentRestScale, parentRestScaleSign }

/* ピッカー球 */
const pickerGroup=new THREE.Group(); scene.add(pickerGroup);
const pickerGeo=new THREE.SphereGeometry(1,16,12);
const pickerMat=new THREE.MeshBasicMaterial({ color:0x00ffff, opacity:0.16, transparent:true, depthTest:false });
const pickerMatHidden=new THREE.MeshBasicMaterial({ color:0x00ffff, opacity:0.0, transparent:true, depthTest:false });
let pickPixelRadius=24;

/* ===== Undo / Redo ===== */
const UNDO_LIMIT = 50;
const undoStack=[]; // [{before:Pose, after:Pose}]
const redoStack=[];
let currentAction=null; // {before, after}

function poseSnapshot(){
  // 位置（子は休止値を維持する仕様だが、将来拡張に備えて position も持つ）
  return bones.map(b=>({
    name:b.name,
    q:b.quaternion.clone(),
    p:b.position.clone()
  }));
}
function applyPose(pose){
  // 名前でマッピング（インデックス変動に耐える）
  const map=new Map(bones.map(b=>[b.name,b]));
  pose.forEach(s=>{
    const b=map.get(s.name);
    if(!b) return;
    b.quaternion.copy(s.q);
    b.position.copy(s.p);
  });
  model?.updateMatrixWorld(true);
  pickerUpdate();
}
function pushAction(action){
  undoStack.push(action);
  if(undoStack.length>UNDO_LIMIT) undoStack.shift();
  redoStack.length=0;
  updateUndoRedoButtons();
}
function updateUndoRedoButtons(){
  btnUndo.disabled = undoStack.length===0;
  btnRedo.disabled = redoStack.length===0;
}
function undo(){
  if(!undoStack.length) return;
  const act=undoStack.pop();
  applyPose(act.before);
  redoStack.push(act);
  updateUndoRedoButtons();
  log("Undo:", act.note||"");
}
function redo(){
  if(!redoStack.length) return;
  const act=redoStack.pop();
  applyPose(act.after);
  undoStack.push(act);
  updateUndoRedoButtons();
  log("Redo:", act.note||"");
}

/* ===== リサイズ ===== */
function handleResize(){
  const headerH=document.querySelector("header").offsetHeight;
  const w=innerWidth, h=innerHeight-headerH;
  renderer.setSize(w,h);
  camera.aspect=w/h; camera.updateProjectionMatrix();
}
addEventListener("resize", handleResize);

/* ===== 読み込み ===== */
const onFilesSelected=(e)=>{
  const list=e.target.files; if(!list?.length) return;
  loadFromFileList(list).catch(showErr);
};
filesInputFolder.addEventListener("change", onFilesSelected);
filesInputFiles.addEventListener("change", onFilesSelected);
async function loadFromFileList(fileList){
  clearModel();

  const files=Array.from(fileList);
  const gltfFile=files.find(f=>/\.gltf$/i.test(f.name));
  const glbFile=files.find(f=>/\.glb$/i.test(f.name));
  const mainFile=gltfFile||glbFile;
  if(!mainFile){ alert(".gltf または .glb が見つかりません"); return; }
  const isGLB=/\.glb$/i.test(mainFile.name);

  const basePath=(mainFile.webkitRelativePath||mainFile.name).replace(/\\/g,"/");
  const baseDir=basePath.includes("/")? basePath.slice(0,basePath.lastIndexOf("/")):"";
  for(const f of files){
    const full=(f.webkitRelativePath||f.name).replace(/\\/g,"/");
    const url=URL.createObjectURL(f);
    const rel=baseDir && full.startsWith(baseDir+"/")? full.slice(baseDir.length+1):full;
    const name=f.name;
    [full,rel,"./"+rel,name,"./"+name,full.toLowerCase(),rel.toLowerCase(),name.toLowerCase()].forEach(k=>filesMap.set(k,url));
  }

  const content=isGLB? await mainFile.arrayBuffer() : await mainFile.text();
  await new Promise((res,rej)=>{
    loader.parse(content,"",(gltf)=>{
      model=gltf.scene||gltf.scenes?.[0];
      modelRoot.add(model);

      // 無地グレー
      model.traverse(o=>{
        if(o.isMesh){
          const m=new THREE.MeshStandardMaterial({color:0xcccccc,roughness:0.8,metalness:0.0,transparent:true,opacity:0.95});
          (Array.isArray(o.material)?o.material:[o.material]).forEach(mm=>mm?.dispose?.());
          o.material=m;
        }
      });

      model.updateMatrixWorld(true);

      skeleton=findFirstSkeleton(model);
      bones=skeleton? skeleton.bones: [];
      if(skeleton){ skeletonHelper=new THREE.SkeletonHelper(model); scene.add(skeletonHelper); }

      setupIKRestInfo();
      pickerRebuild();
      populateBoneSelect(bones);

      panel.hidden=false;
      // 初期ポーズをスタックに積む（Undoの起点）
      pushAction({before: poseSnapshot(), after: poseSnapshot(), note:"初期ポーズ"});
      res();
    },(err)=>rej(err));
  });
}
function findFirstSkeleton(root){ let sk=null; root.traverse(o=>{ if(o.isSkinnedMesh && o.skeleton && !sk) sk=o.skeleton; }); return sk; }
function populateBoneSelect(arr){
  const sel=boneSelect; sel.innerHTML="";
  if(!arr.length){ const opt=document.createElement("option"); opt.textContent="（ボーンなし）"; sel.appendChild(opt); return; }
  arr.forEach((b,i)=>{ const opt=document.createElement("option"); opt.value=i; opt.textContent=`${i}: ${b.name||("Bone_"+i)}`; sel.appendChild(opt); });
  sel.value="0"; selectedBone=arr[0];
}

/* ===== IK 休止情報 ===== */
function setupIKRestInfo(){
  ikMap.clear();
  if(!bones.length) return;

  const pPos=new THREE.Vector3(), cPos=new THREE.Vector3(), pWQ=new THREE.Quaternion(), pScale=new THREE.Vector3();

  bones.forEach(child=>{
    const parent = child.parent && child.parent.isBone ? child.parent : null;
    if(!parent) return;

    // Local（親ローカル）
    const restLen = child.position.length();
    const restDirLocal = restLen>1e-8 ? child.position.clone().normalize() : new THREE.Vector3(0,1,0);
    const restUpLocal = Math.abs(restDirLocal.y)<0.9 ? new THREE.Vector3(0,1,0) : new THREE.Vector3(1,0,0); // 180度反転時の安定軸
    const parentRestLocalQ = parent.quaternion.clone();

    // World（参考）
    parent.getWorldPosition(pPos);
    child.getWorldPosition(cPos);
    const dirW = cPos.clone().sub(pPos); const len = dirW.length();
    const restDirWorld = len>1e-8 ? dirW.clone().normalize() : new THREE.Vector3(0,1,0);
    parent.getWorldQuaternion(pWQ);
    parent.getWorldScale(pScale);
    const parentRestScaleSign = Math.sign(pScale.x*pScale.y*pScale.z) || 1;

    ikMap.set(child,{
      parent, restLen,
      restDirLocal, restUpLocal, parentRestLocalQ,
      restDirWorld, parentRestWorldQ: pWQ.clone(),
      parentRestScale: pScale.clone(),
      parentRestScaleSign
    });
  });
}

/* ===== ピッカー ===== */
chkShowPickers.addEventListener("change",()=>pickerGroup.children.forEach(m=>{ m.material = chkShowPickers.checked? pickerMat : pickerMatHidden; }));
function pickerRebuild(){
  pickerGroup.clear();
  bones.forEach(b=>{
    const m=new THREE.Mesh(pickerGeo, chkShowPickers.checked? pickerMat : pickerMatHidden);
    m.userData.bone=b; pickerGroup.add(m);
  });
  pickerUpdate();
}
function pickerUpdate(){
  const px=pickPixelRadius;
  const fovRad=camera.fov*Math.PI/180;
  const pxToRad=fovRad/renderer.domElement.clientHeight;
  const ang=px*pxToRad;
  const wp=new THREE.Vector3();
  pickerGroup.children.forEach(m=>{
    const b=m.userData.bone; if(!b) return;
    b.getWorldPosition(wp);
    m.position.copy(wp);
    const dist=camera.position.distanceTo(wp);
    m.scale.setScalar(Math.max(1e-4, Math.tan(ang)*dist));
  });
}

/* ===== 左ドラッグ（親のみ回転・World→LocalをworldToLocalで厳密変換） ===== */
let isLeftDragging=false;
let dragPlane=null, dragOffsetWorld=null, dragBone=null, dragInfo=null;
let dragLastDirLocal=new THREE.Vector3();
let dragPrevDirLocal=null;
const tmpV=new THREE.Vector3(), pw=new THREE.Vector3(), tmpA=new THREE.Vector3(), tmpB=new THREE.Vector3();
const tmpQ=new THREE.Quaternion();
const tmpScale=new THREE.Vector3();
const tmpQWorld=new THREE.Quaternion();
let dragLogCounter=0, lastDragLogTime=0;
const DRAG_LOG_LIMIT=200;
function logDragDebug(tag,info){
  const now=performance.now();
  if(dragLogCounter>=DRAG_LOG_LIMIT) return;
  if(now-lastDragLogTime<25) return; // 短時間の連打を抑制
  dragLogCounter++; lastDragLogTime=now;
  const msg=[
    `[drag ${dragLogCounter}] ${tag}`,
    info.boneName?`bone=${info.boneName}`:"",
    info.restDir?`rest=${fmtV(info.restDir)}`:"",
    info.newDir?`new=${fmtV(info.newDir)}`:"",
    info.qDelta?`qΔ=${fmtQ(info.qDelta)}`:"",
    info.parentQ?`parentQ=${fmtQ(info.parentQ)}`:"",
    info.dot!==undefined?`dot=${fmtN(info.dot)}`:"",
    info.len!==undefined?`len=${fmtN(info.len)}`:"",
    info.deltaDeg!==undefined?`deg=${fmtN(info.deltaDeg,2)}`:"",
    info.targetW?`hitW=${fmtV(info.targetW)}`:"",
    info.planeN?`planeN=${fmtV(info.planeN)}`:"",
    info.offsetLen!==undefined?`offLen=${fmtN(info.offsetLen,3)}`:"",
    info.dirW?`dirW=${fmtV(info.dirW)}`:"",
    info.dirWRaw?`dirWRaw=${fmtV(info.dirWRaw)}`:"",
    info.diffL?`diffL=${fmtV(info.diffL)}`:"",
    info.p0L?`p0L=${fmtV(info.p0L)}`:"",
    info.p1L?`p1L=${fmtV(info.p1L)}`:"",
    info.parentScale?`pScale=${fmtV(info.parentScale)}`:"",
    info.parentDet!==undefined?`pDet=${fmtN(info.parentDet,3)}`:"",
    info.parentWQ?`pWQ=${fmtQ(info.parentWQ)}`:""
  ].filter(Boolean).join(" ");
  log(msg);
}

function quatFromDirsStable(from,to,fallbackUp){
  const a=tmpA.copy(from).normalize();
  const b=tmpB.copy(to).normalize();
  const dot=a.dot(b);
  if(dot>0.999999) return tmpQ.identity(); // ほぼ同方向
  if(dot<-0.999999){
    // 反転時：fromと十分非平行な軸を選び、180度回転
    const axis=tmpA.copy(fallbackUp||new THREE.Vector3(0,1,0));
    if(Math.abs(axis.dot(a))>0.9) axis.set(1,0,0);
    axis.cross(a).normalize();
    return tmpQ.setFromAxisAngle(axis, Math.PI);
  }
  // 一般ケース：安定計算（setFromUnitVectors相当だが符号揺れを抑制）
  const s=Math.sqrt((1+dot)*2);
  const invS=1/s;
  const axis=tmpA.crossVectors(a,b);
  tmpQ.set(axis.x*invS, axis.y*invS, axis.z*invS, s*0.5);
  return tmpQ.normalize();
}

function setMouseNDC(ev){
  const r=renderer.domElement.getBoundingClientRect();
  mouseNDC.x=((ev.clientX-r.left)/r.width)*2-1;
  mouseNDC.y=-((ev.clientY-r.top)/r.height)*2+1;
}
function pointSegmentDistSq2D(px,py,ax,ay,bx,by){
  const abx=bx-ax, aby=by-ay;
  const apx=px-ax, apy=py-ay;
  const abLenSq=abx*abx+aby*aby;
  if(abLenSq<1e-12) return apx*apx+apy*apy; // ほぼ点
  const t=Math.max(0,Math.min(1,(apx*abx+apy*aby)/abLenSq));
  const cx=ax+abx*t, cy=ay+aby*t;
  const dx=px-cx, dy=py-cy;
  return dx*dx+dy*dy;
}
function pickBoneByRay(ev){
  if(!bones.length) return null;
  setMouseNDC(ev);
  raycaster.setFromCamera(mouseNDC,camera);
  const hits=raycaster.intersectObjects(pickerGroup.children,false);
  if(hits?.length) return hits[0].object?.userData?.bone || null;

  // フォールバック：線分（ボーン→子ボーン）をスクリーン座標で当たり判定し、「線分元のボーン」を返す
  const rect=renderer.domElement.getBoundingClientRect();
  const mx=ev.clientX-rect.left, my=ev.clientY-rect.top;
  let bestBone=null, bestDistSq=Infinity;

  bones.forEach(bone=>{
    // 親がボーンでない場合は回転対象にならないのでスキップ
    if(!bone.parent || !bone.parent.isBone) return;

    let hasChildSegment=false;
    bone.children.forEach(ch=>{
      if(!ch.isBone) return;
      hasChildSegment=true;

      const p0=tmpA.copy(bone.getWorldPosition(tmpA)).project(camera);
      const p1=tmpB.copy(ch.getWorldPosition(tmpB)).project(camera);
      const x0=(p0.x*0.5+0.5)*rect.width, y0=(-p0.y*0.5+0.5)*rect.height;
      const x1=(p1.x*0.5+0.5)*rect.width, y1=(-p1.y*0.5+0.5)*rect.height;

      const distSq=pointSegmentDistSq2D(mx,my,x0,y0,x1,y1);
      if(distSq<bestDistSq){
        bestDistSq=distSq;
        bestBone=bone;
      }
    });

    // 子ボーンが無い場合は点距離で判定（ほぼ picker と同様の意味合い）
    if(!hasChildSegment){
      const p0=tmpA.copy(bone.getWorldPosition(tmpA)).project(camera);
      const x0=(p0.x*0.5+0.5)*rect.width, y0=(-p0.y*0.5+0.5)*rect.height;
      const distSq=(mx-x0)*(mx-x0)+(my-y0)*(my-y0);
      if(distSq<bestDistSq){
        bestDistSq=distSq;
        bestBone=bone;
      }
    }
  });

  return (bestBone && bestDistSq<=pickPixelRadius*pickPixelRadius)? bestBone : null;
}

function beginDrag(ev,bone){
  controls.enabled=false;
  canvas.classList.add('cursor-move');
  canvas.setPointerCapture(ev.pointerId);

  dragBone=bone;
  dragInfo=ikMap.get(bone);
  dragLastDirLocal.copy(dragInfo?.restDirLocal||new THREE.Vector3(0,1,0));
  dragLogCounter=0; lastDragLogTime=0;
  dragPrevDirLocal=null;

  // 1操作のスナップショット（before）
  currentAction = { before: poseSnapshot(), after: null, note:`ドラッグ: ${bone.name||"(no name)"}` };

  // 親位置を通るドラッグ平面
  if(movePlaneSel.value==="world"){
    dragInfo.parent.getWorldPosition(tmpV);
    dragPlane=new THREE.Plane(new THREE.Vector3(0,1,0), -tmpV.y);
  }else{
    const n=new THREE.Vector3(); camera.getWorldDirection(n);
    dragInfo.parent.getWorldPosition(tmpV);
    dragPlane=new THREE.Plane().setFromNormalAndCoplanarPoint(n,tmpV);
  }

  // オフセット
  setMouseNDC(ev);
  raycaster.setFromCamera(mouseNDC,camera);
  const hit=new THREE.Vector3(); bone.getWorldPosition(tmpV);
  dragOffsetWorld = raycaster.ray.intersectPlane(dragPlane,hit) ? tmpV.clone().sub(hit) : new THREE.Vector3();

  const idx=bones.indexOf(bone); if(idx>=0){ boneSelect.value=String(idx); selectedBone=bone; }
  log("ドラッグ開始:", bone.name||"(no name)");
  if(dragInfo){
    logDragDebug("start",{
      boneName:bone.name||"(no name)",
      restDir:dragInfo.restDirLocal,
      parentQ:dragInfo.parentRestLocalQ
    });
  }
}

function dragMove(ev){
  if(!dragBone||!dragPlane||!dragInfo) return;

  // 平面上の目標点（World）
  setMouseNDC(ev);
  raycaster.setFromCamera(mouseNDC,camera);
  const hit=new THREE.Vector3();
  if(!raycaster.ray.intersectPlane(dragPlane,hit)) return;

  // 親のWorld位置
  dragInfo.parent.getWorldPosition(pw);

  // 目標方向（World）
  const newDirWorldRaw = hit.clone().add(dragOffsetWorld).sub(pw);
  const newDirWorld = newDirWorldRaw.clone();
  if(newDirWorld.lengthSq()<1e-12) return;
  newDirWorld.normalize();

  // World方向を休止時の親ワールド回転の逆でローカルへ（スケール符号のみ反映）
  const invParentRestWQ = dragInfo.parentRestWorldQ.clone().invert();
  const restScaleSign = dragInfo.parentRestScaleSign || 1;

  const newDirLocalRaw = newDirWorld.clone().applyQuaternion(invParentRestWQ);
  if(restScaleSign<0) newDirLocalRaw.negate();

  const lenLocal = newDirLocalRaw.length();
  const newDirLocal = lenLocal<1e-5
    ? dragLastDirLocal.clone()
    : newDirLocalRaw.normalize();
  dragLastDirLocal.copy(newDirLocal);

  // 親ローカル回転差：restDirLocal → newDirLocal（180度反転を安定化）
  const qDeltaLocal = quatFromDirsStable(dragInfo.restDirLocal, newDirLocal, dragInfo.restUpLocal);
  dragInfo.parent.quaternion.copy(dragInfo.parentRestLocalQ.clone().multiply(qDeltaLocal));

  // 子の position は休止値（方向×長さ）に固定
  dragBone.position.copy(dragInfo.restDirLocal.clone().multiplyScalar(dragInfo.restLen));

  dragInfo.parent.updateMatrixWorld(true);
  dragBone.updateMatrixWorld(true);
  pickerUpdate();

  // デバッグログ（間欠）
  const deltaDeg = dragPrevDirLocal
    ? radToDeg(Math.acos(THREE.MathUtils.clamp(dragPrevDirLocal.dot(newDirLocal),-1,1)))
    : 0;
  const tag = deltaDeg>5 ? "jump" : "move";
  const parentDet=dragInfo.parent.matrixWorld.determinant();
  logDragDebug(tag,{
    boneName:dragBone.name||"(no name)",
    restDir:dragInfo.restDirLocal,
    newDir:newDirLocal,
    qDelta:qDeltaLocal,
    parentQ:dragInfo.parent.quaternion,
    parentWQ:dragInfo.parentRestWorldQ,
    parentScale:dragInfo.parentRestScale,
    parentDet,
    dot:dragInfo.restDirLocal.dot(newDirLocal),
    len:lenLocal,
    deltaDeg,
    targetW:hit,
    planeN:dragPlane.normal,
    offsetLen:dragOffsetWorld.length(),
    dirW:newDirWorld,
    dirWRaw:newDirWorldRaw
  });
  dragPrevDirLocal=newDirLocal.clone();
}

function endDrag(ev){
  canvas.releasePointerCapture?.(ev.pointerId);
  controls.enabled=true;
  canvas.classList.remove('cursor-move');

  // 1操作のスナップショット（after）→ Undo スタックへ
  if(currentAction){
    currentAction.after = poseSnapshot();
    pushAction(currentAction);
    currentAction=null;
  }

  logDragDebug("end",{
    boneName:dragBone?.name||"(no name)",
    parentQ:dragInfo?.parent?.quaternion,
    restDir:dragInfo?.restDirLocal
  });
  dragBone=null; dragPlane=null; dragOffsetWorld=null; dragInfo=null; dragPrevDirLocal=null;
}

/* ===== 入力（マウス） ===== */
canvas.addEventListener("pointerdown",(e)=>{
  if(e.button!==0) return;
  const b=pickBoneByRay(e); if(!b) return;
  e.preventDefault(); e.stopPropagation();
  isLeftDragging=true; beginDrag(e,b);
});
canvas.addEventListener("pointermove",(e)=>{ if(isLeftDragging){ e.preventDefault(); dragMove(e); } });
canvas.addEventListener("pointerup",(e)=>{ if(isLeftDragging){ isLeftDragging=false; endDrag(e); } });
canvas.addEventListener("pointercancel",(e)=>{ if(isLeftDragging){ isLeftDragging=false; endDrag(e); } });

/* ===== ショートカット / ボタン ===== */
window.addEventListener("keydown",(e)=>{
  // 入力系要素中は無効
  const t=e.target; if(t && (/INPUT|TEXTAREA|SELECT/).test(t.tagName)) return;

  const k=e.key.toLowerCase();
  const mod=(e.ctrlKey||e.metaKey);
  if(mod && k==='z' && !e.shiftKey){ e.preventDefault(); undo(); }
  else if( (mod && k==='y') || (mod && k==='z' && e.shiftKey) ){ e.preventDefault(); redo(); }
});
btnUndo.addEventListener("click", undo);
btnRedo.addEventListener("click", redo);

/* ===== ジャイロ：相対回転でカメラ制御 ===== */
let gyroActive=false, gyroHandler=null, gyroLogAt=0;
let gyroBaseQ=null, gyroBaseCamQ=null, gyroBaseOffset=null, gyroBaseTarget=null;
const zee=new THREE.Vector3(0,0,1);
const euler=new THREE.Euler();
const q0=new THREE.Quaternion();
const q1=new THREE.Quaternion(-Math.sqrt(0.5),0,0,Math.sqrt(0.5)); // -PI/2 X回転（デバイス座標→three座標補正）
const tmpGyroQ=new THREE.Quaternion();
function deviceOrientationToQuaternion(alpha,beta,gamma,orient=0){
  // DeviceOrientationのalpha(Z軸回り), beta(X軸), gamma(Y軸)をthree座標系へ
  euler.set(THREE.MathUtils.degToRad(beta||0), THREE.MathUtils.degToRad(alpha||0), -THREE.MathUtils.degToRad(gamma||0), "YXZ");
  tmpGyroQ.setFromEuler(euler);
  tmpGyroQ.multiply(q1);
  tmpGyroQ.multiply(q0.setFromAxisAngle(zee, -orient));
  return tmpGyroQ.clone();
}
async function requestGyroPermission(){
  if(typeof DeviceOrientationEvent==="undefined"){ log("ジャイロ: 非対応"); return false; }
  if(typeof DeviceOrientationEvent.requestPermission==="function"){
    const s=await DeviceOrientationEvent.requestPermission().catch(()=> "denied");
    if(s!=="granted"){ log("ジャイロ: 許可されませんでした"); return false; }
  }
  return true;
}
function startGyro(){
  if(gyroActive) return;
  controls.update(); // 現在のカメラ・ターゲットを確定（damping反映）
  gyroBaseOffset=camera.position.clone().sub(controls.target);
  gyroBaseTarget=controls.target.clone();
  gyroBaseCamQ=camera.quaternion.clone();
  gyroBaseQ=null; // デバイス基準は最初のイベントで取得
  gyroHandler=(e)=>{
    if(e.alpha==null&&e.beta==null&&e.gamma==null) return;
    const orientRad = (screen.orientation?.angle||0)*Math.PI/180;
    const gyroQ = deviceOrientationToQuaternion(e.alpha,e.beta,e.gamma,orientRad);
    if(!gyroBaseQ){
      gyroBaseQ=gyroQ.clone();
      log("ジャイロ基準取得");
    }
    const delta = gyroBaseQ.clone().invert().multiply(gyroQ);
    const newQ = delta.multiply(gyroBaseCamQ);
    const offsetRotated = gyroBaseOffset.clone().applyQuaternion(delta);
    camera.position.copy(gyroBaseTarget).add(offsetRotated);
    camera.quaternion.copy(newQ);
    camera.updateMatrixWorld(true);
    controls.target.copy(gyroBaseTarget);
    camera.updateMatrixWorld(true);
    const now=performance.now();
    if(now-gyroLogAt>=300){
      gyroLogAt=now;
      const rot=camera.rotation;
      log(`gyro α=${fmtN(e.alpha,1)} β=${fmtN(e.beta,1)} γ=${fmtN(e.gamma,1)} | cam rot(deg) x=${fmtN(radToDeg(rot.x),1)} y=${fmtN(radToDeg(rot.y),1)} z=${fmtN(radToDeg(rot.z),1)}`);
    }
  };
  addEventListener("deviceorientation", gyroHandler);
  gyroActive=true;
  controls.enabled=false; // ジャイロ中は操作競合を避ける
  btnGyro.textContent="ジャイロ停止";
  log("ジャイロリスナー開始");
}
function stopGyro(){
  if(!gyroActive) return;
  removeEventListener("deviceorientation", gyroHandler);
  gyroActive=false;
  gyroBaseQ=null; gyroBaseCamQ=null; gyroBaseOffset=null; gyroBaseTarget=null;
  controls.enabled=true;
  btnGyro.textContent="ジャイロ開始";
  log("ジャイロリスナー停止");
}
btnGyro.addEventListener("click", async ()=>{
  if(gyroActive){ stopGyro(); return; }
  const ok=await requestGyroPermission();
  if(!ok) return;
  startGyro();
});

/* ===== ループ ===== */
(function tick(){
  if(!gyroActive) controls.update(); // ジャイロ中はOrbitControls無効
  pickerUpdate();
  renderer.render(scene,camera);
  requestAnimationFrame(tick);
})();
handleResize();

/* ===== 片付け・ユーティリティ ===== */
function clearModel(){
  if(model){ modelRoot.remove(model); model=null; }
  if(skeletonHelper){ scene.remove(skeletonHelper); skeletonHelper=null; }
  bones=[]; boneSelect.innerHTML=""; selectedBone=null; panel.hidden=true;
  for(const url of filesMap.values()) URL.revokeObjectURL(url); filesMap.clear();
  pickerGroup.clear(); ikMap.clear();
  undoStack.length=0; redoStack.length=0; updateUndoRedoButtons();
}
</script>
</body>
</html>
